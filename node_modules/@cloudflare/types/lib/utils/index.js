"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  objectKeys: true,
  assertNever: true
};
exports.assertNever = void 0;
exports.objectKeys = objectKeys;
var _enumerable = require("./enumerable");
Object.keys(_enumerable).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _enumerable[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _enumerable[key];
    }
  });
});
// (A - keys of B)
// In set theory, this would be the set complement A âˆ– B (https://en.wikipedia.org/wiki/Complement_(set_theory)#Relative_complement)
// Example:
//      type A = {a: string, b: number, c: boolean}
//      type B = {b: number}
//      type result = Omit<A, keyof B> = {a: string, c: boolean}

/**
 *  Get PropTypes of a component.
 *  @example
 *  const OtherComponent: React.FC<{ foo: string }> = () => <div>{foo}</div>
 *  type MyComponentProps = PropTypes<typeof OtherComponent> & { bar: string } // {foo: string, bar: string}
 */

/**
 * ValueOf: similar to keyof, but picks a value.
 *
 * @example
 * type Person = {
 *   name: string,
 *   phone: number | null
 * }
 *
 * type PhoneType = ValueOf<Person>; // string | number | null
 */

/**
 * Arguments<Fn>: Get type of arguments of a function.
 * @example
 * type Fn = (foo: string, bar: number) => void
 * type FnArguments = Arguments<Fn> // [string, number]
 */

/**
 * Get type of array element
 *
 * @example
 * const Names = ["Robert", "Ollie", "John", "Cina", "Millie"] // typeof Names === string[]
 * type Name = ValueOfArray<typeof Names> // string
 *
 * @example
 * // typeof readonlyNames === readonly ["Robert", "Ollie", "John", "Cina", "Millie"]
 * const nameTuple = ["Robert", "Ollie", "John", "Cina", "Millie"] as const
 * // Name === "Robert" | "Ollie" | "John" | "Cina" | "Millie"
 * type Name = ValueOfReadonlyArray<typeof nameTuple>
 */

/**
 * Overwrite certain keys with new types.
 *
 * @example
 * type A = {a: string, b?: string}
 * type result = Overwrite<A, {b: string}> = {a: string, b: string}
 * (Note that b is no longer optional)
 */

/**
 * Converts union to intersection.
 *
 * @example
 * type A = "hello" | 5
 * type IntersectionA = UnionToIntersection<A> = "hello" & 5
 */

/**
 * Doing keyof UnionOfObjects in TypeScript will give you intersection of keys. For example:
 * type UnionOfObjects = {a: string, b: number} | {a: string}
 * type Keys = keyof UnionOfObjects // "a"[]
 *
 * Sometimes, you might want all possible keys, in other words, you want union of keys. You can use this type for it.
 *
 * @example
 * type UnionOfObjects = {a: string, b: number } | {a: string}
 * type AllKeys = KeyOfUnion<UnionOfObjects> // "a" | "b"
 */

/**
 * Converts readonly array to non-readonly array.
 *
 * @example
 * const ReadonlyArray = [5, 4] as const;
 *
 * type NonReadonlyArray = NonReadonly<typeof ReadonlyArray>
 */

/**
 * Remove types from T that are assignable to U
 */

/**
 * Remove types from T that are not assignable to U
 */

/**
 * Represents Some value, or None
 */

/**
 * Given a tuple, get the type of the head of the tuple
 */

/**
 * Given a tuple, return a new tuple without the head
 */

/**
 * Append T to R where R is a tuple
 */

/**
 * Reverses the given tuple type.
 */

/**
 * Force TS to load a type that has not been computed
 * (to resolve composed types that TS hasn't resolved).
 * https://pirix-gh.github.io/ts-toolbelt/modules/_any_compute_.html
 *
 * @example
 * // becomes {foo: string, baz: boolean}
 * type Foo = Compute<{bar: string} & {baz: boolean}>
 */

/**
 * Same as Partial, but recursively.
 *
 * @example
 * type A = {
 *   foo: {
 *     bar: string
 *   }
 * }
 *
 * type B = PartialDeep<A>
 * // Becomes { foo?: {bar?: string | undefined} | undefined }
 */

/**
 * Selectively apply Partial to certain properties.
 *
 * @example
 * type T = {
 *   foo: string;
 *   bar: string;
 *   baz?: string | undefined;
 * }
 *
 * type OptionalBar = PartialKeys<T, "bar"> // { foo: string; bar?: string | undefined; baz?: string | undefined; }
 */

/**
 * Selectively apply Required to certain properties.
 *
 * @example
 * type T = {
 *   foo: string;
 *   bar?: string | undefined;
 *   baz?: string | undefined;
 * }
 *
 * type RequiredBar = RequiredKeys<T, "bar"> // { foo: string; bar: string; baz?: string | undefined; }
 */

/**
 * Selectively apply Readonly to certain properties.
 *
 * @example
 * type T = {
 *   foo: string;
 *   bar: string;
 *   readonly baz: string;
 * }
 *
 * type ReadonlyBar = ReadonlyKeys<T, "bar"> // { foo: string; readonly bar: string; readonly baz: string; }
 */

/**
 * Generates the typings for usage with Object.keys
 *
 *  @example
 *  const Locations = { "Cina": "Austin", "John": "Austin", "Kevin": "Austin", "Nicky": "San Francisco", "Robert": "San Francisco" }
 *  const KeysFromLocations = objectKeys(Locations)
 */
function objectKeys(t) {
  return Object.keys(t);
}

/*
 * Get a type of awaited Promise value.
 *
 * @example
 * type StringPromise = Promise<string>
 *
 * type Value = PromiseType<StringPromise> // string
 */

/**
 * Should be used in the `default:` case of a switch.
 * Will cause a compilation-time type error if the switch is not exhaustive.
 * See https://www.typescriptlang.org/docs/handbook/advanced-types.html
 *
 * @param x
 * @param returnValue If provided, doesn't throw at runtime, but returns this value.
 *
 * @example
 * type Type = "error" | "success" | "info" | "warning"
 *
 * const getIcon = (type: Type) => {
 *   switch (type) {
 *     case 'success':
 *       return 'ok';
 *     case 'error':
 *       return 'sad';
 *     case 'info':
 *       return 'info-sign';
 *     default:
 *       return assertNever(type); // Shows error, because 'warning' is not handled.
 *   }
 * };
 */
var assertNever = function assertNever(x, returnValue) {
  if (returnValue !== undefined) {
    throw new Error('Unexpected object: ' + x);
  } else {
    return returnValue;
  }
};
exports.assertNever = assertNever;